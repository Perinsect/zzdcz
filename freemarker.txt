freemarker
	文本：文本会照着原样来输出。
	FTL 标签 (指令)：这些标签的名字以 # 开头。(用户自定义的FTL标签则需要使用 @ 来代替 #)  区分大小写
	注释：使用 <#-- and --> 来标识。
	插值：这部分的输出会被计算的值来替换，插值由 ${ and } 所分隔，插值只能用于文本中
	值域
		值域表达式本身并没有方括号，比如这样编写代码 <#assign myRange = 0..<x>， 而不是 <#assign myRange = [0..<x]>。 后者会创建一个包含值域的序列。方括号是切分语法的一部分，就像 seq[myRange]。
		可以在 .. 的两侧编写算术表达式而不需要圆括号， 就像 n + 1 ..< m / 2 - 1。..，..<， 
		..! 和 ..* 是运算符， 所以它们中间不能有空格。就像 n .. <m 这样是错误的，但是 n ..< m 这样就可以。
		
		start..end： 包含结尾的值域。比如 1..4 就是 [1, 2, 3, 4]， 而 4..1 就是 [4, 3, 2, 1]。当心一点， 包含结尾的值域不会是一个空序列，所以 0..length-1 就是 错误的，因为当长度是 0 时， 序列就成了 [0, -1]。
		
		start..<end 或 start..!end： 不包含结尾的值域。比如 1..<4 就是 [1, 2, 3]，4..<1 就是 [4, 3, 2], 而 1..<1 表示 []。请注意最后一个示例； 结果可以是空序列，和 ..< 和 ..! 没有区别; 最后这种形式在应用程序中使用了 < 字符而引发问题(如HTML编辑器等)。
		
		start..*length： 限定长度的值域，比如 10..*4 就是 [10, 11, 12, 13]，10..*-4 就是 [10, 9, 8, 7]，而 10..*0 表示 []。当这些值域被用来切分时， 如果切分后的序列或者字符串结尾在指定值域长度之前，则切分不会有问题；请参考 序列切分 来获取更多信息。
		
		start..： 无右边界值域。这和限制长度的值域很像，只是长度是无限的。 比如 1.. 就是 [1, 2, 3, 4, 5, 6, ... ]，直到无穷大。 但是处理(比如列表显示)这种值域时要万分小心，处理所有项时， 会花费很长时间，直到内存溢出应用程序崩溃。 和限定长度的值域一样，当它们被切分时， 遇到切分后的序列或字符串结尾时，切分就结束了。
		
	类型
		标量：字符串，数字，布尔（true 或者 false ）
		容器：哈希表（类似字典或者对象），序列，集合
		子程序：方法，函数，用户自定义指令
		节点
	常用指令
		if指令：   
			<#if 判断条件> ...<#else>... </#if>   
		list指令：   遍历列表，类似增强for
			<#list 列表 as 项> ${项} </#list>
			<#list 列表> <#items as 项>${项}</#items></#list>    
			<#list 列表 as 项> ${项}<#sep>, </#list>       <#sep>：项之间使用逗号分隔，最后一项后面没有逗号
		include指令  可以在模板中插入其他文件的内容（重用代码片段）
			<#include "文件路径">      用目标文件内容替换当前代码
	空值处理
		${user!"visitor"}    当 user 不存在于数据模型时, 模板将会将 user 的值表示为字符串 "visitor"
		<#if user??><h1>Welcome ${user}!</h1></#if>      user不存在时忽略这条语句
		多级访问的变量应该用()括住   <#if (animals.python.price)??>...</#if>    ${(animals.python.price)!"visitor"}
				   
	内建函数：类似于方法   是 FreeMarker在数值上添加的。 为了清晰子变量是哪部分，使用 ?(问号)代替 .(点)来访问它们
		